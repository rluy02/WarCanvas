<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="CapitanManzana"><title>Source: Render/TableroGrafico.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">WarCanvas Docs</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-namespaces"><div>Namespaces</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Escenas.html">Escenas</a></div><div class="sidebar-section-children"><a href="Logica.html">Logica</a></div><div class="sidebar-section-children"><a href="Render.html">Render</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"><div class="menu-item navbar-item"><a id="repository" href="https://github.com/CapitanManzana/WarCanvas" target="_blank">Repositorio</a></div></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">Render_TableroGrafico.js</h1></header><article><pre class="prettyprint source lang-js"><code>import { Eventos } from "../Events.js";
import { EventBus } from "../EventBus.js";
import { turnoJugador } from "../Logica/Turno.js";
import Celda from "../Logica/Celda.js";

/**
 * Gestión gráfica del tablero principal: crea rectángulos por casilla,
 * pinta rangos de movimiento, fragmentos de mapa y gestiona interacciones.
 * @class TableroGrafico
 * @memberof Render
 */
class TableroGrafico {
    /**
     * Constructor de la capa gráfica del tablero.
     * @param {Phaser.Scene} escena - escena de Phaser donde se dibuja
     * @param {Tablero} tablero - instancia de la lógica del tablero
     * @param {PanelLateral} PanelLateral - panel lateral para mostrar confirmaciones
     * @param {number} [tamCasilla=64] - tamaño en píxeles de cada casilla
     */
    constructor(escena, tablero, PanelLateral, tamCasilla = 64) {
        this.escena = escena;
        this.tablero = tablero;
        this.tamCasilla = tamCasilla;
        this.graficos = this.dibujarTablero(); //Este tablero visual esta lleno de "rects" //Phaser.GameObjects.Rectangle

        this.mapaTopografico = this.escena.textures.get('mapaTopo').getSourceImage();
        this.mapaSatelital = this.escena.textures.get('mapaSat').getSourceImage();

        this.mapaTopograficoWidth = this.mapaTopografico.width;
        this.mapaTopograficoHeight = this.mapaTopografico.height;

        this.fragmentoAncho = this.mapaTopograficoWidth / this.tablero.columnas;
        this.fragmentoAlto = this.mapaTopograficoHeight / this.tablero.filas;

        this.celdaSeleccionada = null; // La celda que estas seleccionando
        this.celdasColoreadas = []; // Las celdas a las que te puedes mover
        this.PanelLateral = PanelLateral;

        // Separar capas de selección/movimiento de capas de eventos
        this.casillasPintadas = [];      // Para selección/movimiento (se limpian con limpiarTablero)
        this.casillasEventos = [];       // Para eventos (persisten hasta limpiarEventos)
        this.casillasFichasMovidas = []; // Para piezas movidas (persisten hasta resetear turno)

        //Si se esta moviendo
        this.moviendoPieza = false;

        EventBus.on(Eventos.PIECE_END_ACTIONS, () => {
            this.restTablero();
        });

        EventBus.on(Eventos.CHANGE_TURN, () => {
            this.resetCasillasFichasMovidas();
        });

        for (let fila = 0; fila &lt; this.tablero.filas; fila++) {
            for (let col = 0; col &lt; this.tablero.columnas; col++) {

                if (col &lt; 3) {
                    this.dibujarFragmentoMapa(fila, col, "J1")
                }
                else if (col > 6) {
                    this.dibujarFragmentoMapa(fila, col, "J2")
                }
            }
        }
    }

    /**
     * Dibuja la malla gráfica del tablero: rectángulos interactivos por casilla.
     * @returns {Array&lt;Array&lt;Phaser.GameObjects.Rectangle>>} matriz de rectángulos que representan las celdas
     */
    dibujarTablero() {
        let graficos = [];

        for (let fila = 0; fila &lt; this.tablero.filas; fila++) {
            graficos[fila] = [];
            for (let col = 0; col &lt; this.tablero.columnas; col++) {
                const color = (fila + col) % 2 === 0 ? 0xffffff : 0xcccccc;
                //los rectangulos se empiezan a dibujar desde el centro (por eso, +tamCasillas/2)
                const x = col * this.tamCasilla + this.tamCasilla / 2;
                const y = fila * this.tamCasilla + this.tamCasilla / 2;

                // new Rectangle(scene, x, y, [width], [height], [fillColor], [fillAlpha])
                const rect = this.escena.add.rectangle(
                    x, y, this.tamCasilla, this.tamCasilla, color
                ).setStrokeStyle(1, 0x000000)
                    .setInteractive();

                // Detectar click
                rect.on('pointerdown', () => {
                    this.onCeldaClick(fila, col);
                });

                graficos[fila][col] = rect;
            }
        }

        return graficos;
    }

    /**
     * Manejador de clic en una celda gráfica.
     * Determina acciones (seleccionar pieza, mover, atacar o disparar artillería).
     * @param {number} fila - fila de la celda clicada
     * @param {number} col - columna de la celda clicada
     */
    onCeldaClick(fila, col) {
        const celda = this.tablero.getCelda(fila, col);
        const pieza = celda.getPieza();
        const jugador = pieza ? pieza.getJugador() : "";

        // Si no hay celda seleccionada y no esta vacía se marcan las oppciones de la pieza
        if (pieza &amp;&amp; this.celdaSeleccionada == null &amp;&amp; !this.moviendoPieza &amp;&amp; !pieza.getMovida() &amp;&amp; jugador == turnoJugador) {
            // Si la celda contiene una pieza
            if (!celda.estaVacia()) {
                this.colorearRango(fila, col);
            }
        }
        else {
            // Como ya hay una celda seleccionada, vemos si la nueva celda es vacía o enemigo, para ver si movemos o atacamos
            if (!this.tablero.getPiezaActiva()) return;

            //Si es artilleria va aparte
            if (this.tablero.getPiezaActiva().getTipo() === "Artilleria" &amp;&amp; this.tablero.getPiezaActiva().puedeDisparar() &amp;&amp; this.esTipoCelda(fila, col)) {

                this.tablero.getPiezaActiva().lanzarProyectil(fila, col, this.escena, this.tablero);
                EventBus.emit(Eventos.PIECE_MOVED, this.tablero.getPiezaActiva(), false);

                this.limpiarTablero();
                this.tablero.resetPiezaActiva();
            }
            // Si es vacía se mueve
            else if (this.esTipoCelda(fila, col, "vacia") &amp;&amp; !this.tablero.getPiezaActiva().getMovida() &amp;&amp; this.tablero.getPiezaActiva().getJugador() == turnoJugador) {
                //Dibuja la conquista
                this.dibujarFragmentoMapa(fila, col, this.tablero.getPiezaActiva().getJugador())

                this.moviendoPieza = true;
                //Se limpia el tablero
                this.limpiarTablero();

                //Se informa del movimiento de pieza
                this.tablero.moverPieza(fila, col);
                this.colorearRango(fila, col);
            }
            else if (this.esTipoCelda(fila, col, "enemigo") &amp;&amp; !this.tablero.getPiezaActiva().getMovida() &amp;&amp; this.tablero.getPiezaActiva().getJugador() == turnoJugador) {
                this.moviendoPieza = false;

                // Combate
                this.confirmarAtaque(fila, col, this.celdaSeleccionada);
                // Posible Ataque si se confirma en el panel Lateral
                this.tablero.ataque(fila, col);
            }
            else if (!this.moviendoPieza) {
                this.limpiarTablero();
                this.celdaSeleccionada = null;
            }
        }
    }

    /**
     * Colorea el rango de movimiento/ataque de la pieza situada en (fila,col).
     * Marca la casilla de la pieza y añade capas para las celdas alcanzables.
     * @param {number} fila - fila de la pieza seleccionada
     * @param {number} col - columna de la pieza seleccionada
     */
    colorearRango(fila, col) {
        let celda = this.tablero.getCelda(fila, col);

        this.limpiarCapas();

        this.celdasColoreadas = this.tablero.piezaSeleccionada(fila, col);
        //La de la ficha actual
        this.graficos[fila][col].setStrokeStyle(3, 0xf5a927);
        this.casillasPintadas.push(this.crearCapa(fila, col, 0xffc107, 0.3));

        for (let cel of this.celdasColoreadas) {
            if (cel.tipo == "vacia") {
                this.graficos[cel.fil][cel.col].setStrokeStyle(3, 0x69CF4E);
                this.casillasPintadas.push(this.crearCapa(cel.fil, cel.col, 0x00ff00, 0.3));
            }
            else if (cel.tipo == "enemigo") {
                this.graficos[cel.fil][cel.col].setStrokeStyle(3, 0xF23A1D);
                this.casillasPintadas.push(this.crearCapa(cel.fil, cel.col, 0xff0000, 0.3));
            }
        }

        this.celdaSeleccionada = celda;
    }

    /**
     * Crea una capa coloreada sobre una celda.
     * @param {number} fila - fila
     * @param {number} col - columna
     * @param {number|string} color - color en formato hexadecimal (0x...)
     * @param {number} transparencia - nivel de alfa (0.0 - 1.0)
     * @returns {Phaser.GameObjects.Rectangle} la capa creada
     */
    crearCapa(fila, col, color, transparencia) {
        const x = col * this.tamCasilla + this.tamCasilla / 2;
        const y = fila * this.tamCasilla + this.tamCasilla / 2;
        const capa = this.escena.add.rectangle(x, y, this.tamCasilla, this.tamCasilla, color, transparencia);
        return capa;
    }

    /**
     * Limpia todas las capas coloreadas del tablero.
     */
    limpiarCapas() {
        this.casillasPintadas.forEach(o => o.destroy());
        this.casillasPintadas = [];
    }

    /**
     * Comprueba si una coordenada dada está entre las celdas coloreadas y, opcionalmente, si coincide el tipo.
     * @param {number} fil - fila objetivo
     * @param {number} col - columna objetivo
     * @param {string} [tipo=""] - tipo de celda a comprobar ('vacia'|'enemigo')
     * @returns {boolean} true si la celda coincide con alguna de las coloreadas
     */
    esTipoCelda(fil, col, tipo = "") {
        for (let celda of this.celdasColoreadas) {
            if (tipo == "") {
                if (celda.fil == fil &amp;&amp; celda.col == col) return true;
            }
            else {
                if (celda.fil == fil &amp;&amp; celda.col == col &amp;&amp; celda.tipo == tipo) return true;
            }
        }

        return false;
    }

    /**
     * Resetea las casillas coloreadas y elimina la selección actual.
     * Restaura el estilo por defecto de las casillas afectadas.
     */
    limpiarTablero() {

        this.limpiarCapas();
        let i = 0;
        // Descolorear las anteriores
        for (let i = 0; i &lt; this.celdasColoreadas.length; i++) {
            let { fil, col } = this.celdasColoreadas[i];
            this.graficos[fil][col].setStrokeStyle(1, 0x000000);
        }

        if (this.celdaSeleccionada) {
            //Desmarcamos la casilla central
            let f = this.celdaSeleccionada.getPosicion().fila;
            let c = this.celdaSeleccionada.getPosicion().col;
            this.graficos[f][c].setStrokeStyle(1, 0x000000);
        }

        this.celdasColoreadas = [];
    }

    /**
     * Confirma un ataque entre la pieza seleccionada y la celda objetivo.
     * @param {number} fila - fila de la celda objetivo
     * @param {number} columna - columna de la celda objetivo
     * @param {Celda} celdaSeleccionada - celda de la pieza atacante
     */
    confirmarAtaque(fila, columna, celdaSeleccionada) {

        let casillaAtacante = this.tablero.getCelda(celdaSeleccionada.fila, celdaSeleccionada.columna);
        let casillaDefensa = this.tablero.getCelda(fila, columna);
        let atacante = casillaAtacante.getPieza().getJugador();
        let defensa = casillaDefensa.getPieza().getJugador();
        let atacantePieza = this.tablero.getCelda(celdaSeleccionada.fila, celdaSeleccionada.columna).getPieza().getTipo();
        let defensaPieza = this.tablero.getCelda(fila, columna).getPieza().getTipo();
        this.PanelLateral.updateInfo(defensaPieza, atacantePieza, atacante, defensa, "Atacar", casillaAtacante, casillaDefensa);
    }

    /**
     * Dibuja un fragmento del mapa (topográfico o satelital) dentro de una celda.
     * @param {number} fila - fila de la celda
     * @param {number} col - columna de la celda
     * @param {string} tipoJugador - 'J1' o 'J2' para elegir mapa
     */
    dibujarFragmentoMapa(fila, col, tipoJugador) {
        // Determina qué mapa usar
        const key = tipoJugador === 'J1' ? 'mapaTopo' : 'mapaSat';

        const textura = this.escena.textures.get(key).getSourceImage();

        const cropX = col * this.fragmentoAncho;
        const cropY = fila * this.fragmentoAlto;

        const x = col * this.tamCasilla + this.tamCasilla / 2;
        const y = fila * this.tamCasilla + this.tamCasilla / 2;

        // Borra la imagen anterior si existe
        if (this.graficos[fila][col].imagen &amp;&amp; this.graficos[fila][col].imagen.mapKey != key) {
            this.graficos[fila][col].imagen.destroy();
            this.tablero.conquistarCelda(tipoJugador, true);
        }
        else if (!this.graficos[fila][col].imagen) {
            this.tablero.conquistarCelda(tipoJugador, false);
        }

        const zoom = 1.3;
        const renderSize = this.tamCasilla * zoom;

        // Crea un RenderTexture que actúa como "mini lienzo" para la celda
        const rt = this.escena.add.renderTexture(x, y, renderSize, renderSize)
            .setOrigin(0.5)
            .setDepth(0);

        // Escala proporcional al fragmento del mapa
        const scaleX = renderSize / this.fragmentoAncho;
        const scaleY = renderSize / this.fragmentoAlto;

        // Dibuja el fragmento del mapa en el renderTexture escalado a la celda
        rt.draw(key, -cropX * scaleX, -cropY * scaleY, key)
            .setScale(scaleX, scaleY);
        rt.mapKey = key;

        this.graficos[fila][col].imagen = rt;
    }

    /**
     * Borra el fragmento de mapa renderizado en una celda y actualiza contadores.
     * @param {number} fila - fila de la celda
     * @param {number} col - columna de la celda
     * @param {string} jugadorAnterior - 'J1' o 'J2' que había conquistado la casilla
     * @returns {void}
     */
    borrarFragmentoMapa(fila, col, jugadorAnterior) {
        // Verificar que existe imagen
        if (!this.graficos[fila][col].imagen) return;

        // Destruir la imagen del mapa
        this.graficos[fila][col].imagen.destroy();
        this.graficos[fila][col].imagen = null;
        this.tablero.borrarCelda(jugadorAnterior);
    }

    /**
     * Dibuja un fragmento del mapa (topográfico o satelital) dentro de una celda.
     * @param {number} fila - fila de la celda
     * @param {number} col - columna de la celda
     * @param {string} tipoJugador - 'J1' o 'J2' para elegir mapa
     */
    dibujarFragmentoMapa(fila, col, tipoJugador) {
        // Determina qué mapa usar
        const key = tipoJugador === 'J1' ? 'mapaTopo' : 'mapaSat';

        const textura = this.escena.textures.get(key).getSourceImage();

        const cropX = col * this.fragmentoAncho;
        const cropY = fila * this.fragmentoAlto;

        const x = col * this.tamCasilla + this.tamCasilla / 2;
        const y = fila * this.tamCasilla + this.tamCasilla / 2;

        // Borra la imagen anterior si existe
        if (this.graficos[fila][col].imagen &amp;&amp; this.graficos[fila][col].imagen.mapKey != key) {
            this.graficos[fila][col].imagen.destroy();
            this.tablero.conquistarCelda(tipoJugador, true);
        }
        else if (!this.graficos[fila][col].imagen) {
            this.tablero.conquistarCelda(tipoJugador, false);
        }

        const zoom = 1.3;
        const renderSize = this.tamCasilla * zoom;

        // Crea un RenderTexture que actúa como "mini lienzo" para la celda
        const rt = this.escena.add.renderTexture(x, y, renderSize, renderSize)
            .setOrigin(0.5)
            .setDepth(0);

        // Escala proporcional al fragmento del mapa
        const scaleX = renderSize / this.fragmentoAncho;
        const scaleY = renderSize / this.fragmentoAlto;

        // Dibuja el fragmento del mapa en el renderTexture escalado a la celda
        rt.draw(key, -cropX * scaleX, -cropY * scaleY, key)
            .setScale(scaleX, scaleY);
        rt.mapKey = key;

        this.graficos[fila][col].imagen = rt;
    }

    /**
     * Borra el fragmento de mapa renderizado en una celda y actualiza contadores.
     * @param {number} fila - fila de la celda
     * @param {number} col - columna de la celda
     * @param {string} jugadorAnterior - 'J1' o 'J2' que había conquistado la casilla
     */
    borrarFragmentoMapa(fila, col, jugadorAnterior) {
        // Verificar que existe imagen
        if (!this.graficos[fila][col].imagen) return;

        // Destruir la imagen del mapa
        this.graficos[fila][col].imagen.destroy();
        this.graficos[fila][col].imagen = null;
        this.tablero.borrarCelda(jugadorAnterior);
    }

    /**
     * Colorea una celda específica con un color dado y nivel de alfa.
     * @param {number} fila - fila de la celda
     * @param {number} col - columna de la celda
     * @param {number|string} color 
     * @param {number} alpha 
     */
    coloreaCelda(fila, col, color, alpha = 0.45) {
        const capa = this.crearCapa(fila, col, color, alpha);
        capa.setDepth(9); // Solo aquí usamos setDepth
        this.casillasEventos.push({ capa, fila, col });
    }

    /**
     * Limpia los eventos gráficos asociados a las casillas.
     */
    limpiarEventos() {
        this.casillasEventos.forEach(obj => obj.capa.destroy());
        this.casillasEventos = [];
    }

    /**
     * Resetea el estado del tablero gráfico.
     * Desactiva movimientos y selecciones actuales.
     */
    restTablero() {
        this.moviendoPieza = false;
        this.movimientoIniciado = false;

        this.limpiarTablero();
        if (this.tablero.getPiezaActiva()) this.marcarCasillaMovida(this.tablero.getPiezaActiva().fil, this.tablero.getPiezaActiva().col);
        this.celdaSeleccionada = null;
    }

    /**
     * Desactiva la interactividad de todas las casillas del tablero.
     */
    desactivarTablero() {
        for (let fila = 0; fila &lt; this.tablero.filas; fila++) {
            for (let col = 0; col &lt; this.tablero.columnas; col++) {
                this.graficos[fila][col].disableInteractive();
            }
        }
    }

    /**
     * Marca una casilla como movida, añadiendo una capa amarilla semi-transparente.
     * @param {number} fila - fila
     * @param {number} col - columna
     */
    marcarCasillaMovida(fila, col) {
        const capa = this.crearCapa(fila, col, 0x3b3b3b3b, 0.5);
        capa.setDepth(8);
        this.casillasFichasMovidas.push({ capa, fila, col });
    }

    /**
     * Resetea las casillas marcadas como movidas.
     */
    resetCasillasFichasMovidas() {
        this.casillasFichasMovidas.forEach(obj => obj.capa.destroy());
        this.casillasFichasMovidas = [];
        this.tablero.resetPiezaActiva();
    }
}

export default TableroGrafico;</code></pre></article></section><footer class="footer" id="PeOAagUepe"><div class="wrapper">© 2024 WarCanvas. Todos los derechos reservados.</div></footer></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">WarCanvas Docs</a><div class="mobile-nav-links"><div class="menu-item navbar-item"><a id="repository-mobile" href="https://github.com/CapitanManzana/WarCanvas" target="_blank">Repositorio</a></div></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-namespaces"><div>Namespaces</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Escenas.html">Escenas</a></div><div class="sidebar-section-children"><a href="Logica.html">Logica</a></div><div class="sidebar-section-children"><a href="Render.html">Render</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>